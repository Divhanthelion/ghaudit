# Cross-Language Vulnerability Pattern Abstraction for Tree-sitter

Abstract vulnerability patterns that compile to language-specific tree-sitter queries are feasible but require a carefully designed intermediate representation, a DSL with language-aware compilation, and acceptance of fundamental trade-offs between generality and precision. This report synthesizes research across static analysis tool architectures, DSL design, language-specific vulnerability manifestations, and unified program representations to provide actionable guidance for building such a system.

## The core architectural challenge

Building a security auditor that abstracts patterns across Rust, Python, JavaScript, and Go requires solving three interconnected problems: representing diverse syntax structures in a common schema, expressing detection patterns at the right abstraction level, and compiling those patterns down to efficient tree-sitter queries. Existing tools have pioneered different approaches to this challenge, each with instructive trade-offs.

**Semgrep** uses a Generic AST that serves as "roughly the union of ASTs for all supported languages." Tree-sitter parses each language into a concrete syntax tree, which language-specific translators convert to this common representation. Pattern matching then operates on the generic form, enabling rules like `$FUNC($...ARGS)` to match function calls across languages. The strength is intuitive patterns that mirror target code; the limitation is semantic information loss during translation.

**CodeQL** takes a database approach, extracting code into relational tuples with language-specific schemas but shared analysis libraries. The QL query language provides declarative abstractions, with language modules implementing predicates like `localFlowStep()` that feed into shared dataflow algorithms. This enables deep semantic analysis but requires significant per-language infrastructure and a steep learning curve.

**Joern's Code Property Graphs** merge AST, control flow, and data dependence into a unified graph structure. All language frontends produce the same CPG schema, enabling queries like `cpg.call.name("exec").argument.reachableBy(cpg.method.name("getInput")).l` to work across languages. The graph representation excels at taint-style patterns but requires graph-thinking rather than pattern-thinking.

The key architectural lesson is that **successful cross-language tools separate parsing (language-specific), representation (unified IR), and querying (language-agnostic)**. For tree-sitter targets, this suggests a layered architecture where abstract patterns compile through an intermediate representation before generating language-specific queries.

## A DSL design that balances expressiveness with compilability

The ideal DSL for cross-language security patterns should feel like writing code patterns (following Semgrep's "patterns that look like code" philosophy) while supporting the semantic constructs needed for vulnerability detection. Based on analysis of existing pattern languages, the recommended design combines declarative structure with code-like pattern syntax.

**Core syntax elements** should include:
- **Metavariables** using `$NAME` for single captures and `$...NAME` for sequences (consistent with Semgrep's proven approach)
- **Typed metavariables** like `$EXPR`, `$STMT`, `$IDENT` for precision when needed
- **Pattern combinators** using `all`, `any`, `not`, and `inside` for composition
- **Taint specifications** with explicit `sources`, `sinks`, `sanitizers`, and `propagators` blocks

**An abstract pattern for SQL injection** might look like:

```yaml
rule:
  id: sql-injection-string-concat
  abstract-pattern:
    taint:
      sources:
        - kind: user-input
      sinks:
        - kind: sql-execution
          pattern: database.execute($QUERY)
          focus: $QUERY
      propagators:
        - pattern: $TO = string-format($TEMPLATE, $...ARGS)
          from: $...ARGS
          to: $TO
        - pattern: $TO = string-concat($LEFT, $RIGHT)  
          from: [$LEFT, $RIGHT]
          to: $TO
  severity: critical
  cwe: CWE-89
```

This abstract pattern uses **semantic kinds** (`user-input`, `sql-execution`, `string-format`, `string-concat`) that map to language-specific constructs during compilation. The DSL compiler maintains mapping tables translating these abstract concepts to concrete patterns per language.

## Language-specific vulnerability manifestations demand rich mappings

SQL injection manifests fundamentally differently across the four target languages, requiring detailed mapping tables that the DSL compiler uses during code generation.

**Python** vulnerabilities typically involve f-strings, `.format()`, or `%` formatting in query construction. The vulnerable pattern `cursor.execute(f"SELECT * FROM users WHERE id = '{user_id}'")` contrasts with safe parameterized queries using tuple arguments. Detection must recognize all Python string formatting idioms: `f"{var}"`, `"{}".format(var)`, `"%s" % var`, and `+` concatenation. The psycopg2, SQLAlchemy, and sqlite3 libraries each have distinct API patterns for safe vs. unsafe usage.

**JavaScript** vulnerabilities center on template literals with `${interpolation}` and string concatenation with `+`. The node-postgres, sequelize, and knex libraries have different parameterization syntaxes. A key detection marker is `.query()` calls with template literals vs. parameterized array arguments.

**Go** vulnerabilities commonly involve `fmt.Sprintf()` for query construction. The `database/sql` package uses `?` or `$1` placeholders, while GORM provides query builder methods. Detection patterns must distinguish `db.Query(fmt.Sprintf("SELECT * FROM users WHERE id = %s", userId))` (vulnerable) from `db.Query("SELECT * FROM users WHERE id = $1", userId)` (safe).

**Rust** offers compile-time query validation through `sqlx::query!()` macros, providing unique safety guarantees. Vulnerabilities still occur with `format!()` macro usage in dynamic query construction with the base `sqlx::query()` function. The `diesel` ORM uses type-safe query builders that prevent injection by design.

The mapping table for `string-format` alone requires:

| Abstract Concept | Python | JavaScript | Go | Rust |
|-----------------|--------|------------|-----|------|
| `string-format` | `f"{$VAR}"`, `"{}".format($VAR)`, `"%" % $VAR` | `` `${$VAR}` `` | `fmt.Sprintf("%s", $VAR)` | `format!("{}", $VAR)` |
| `string-concat` | `$L + $R` | `$L + $R`, `$L.concat($R)` | `$L + $R` | `$L + &$R`, `format!("{}{}", $L, $R)` |
| `sql-execute` | `cursor.execute($Q)`, `engine.execute($Q)` | `connection.query($Q)`, `pool.query($Q)` | `db.Query($Q)`, `db.Exec($Q)` | `sqlx::query($Q)`, `conn.execute($Q)` |

## Tree-sitter query generation presents grammar-specific challenges

Compiling abstract patterns to tree-sitter queries requires handling significant differences in how each language's grammar names and structures nodes. The fundamental challenge is that semantically equivalent constructs have different tree-sitter representations.

**Function calls** illustrate this divergence:

```scheme
; Python
(call
  function: (identifier) @fn_name
  arguments: (argument_list))

; JavaScript  
(call_expression
  function: (identifier) @fn_name
  arguments: (arguments))

; Go
(call_expression
  function: (selector_expression
    operand: (identifier) @package
    field: (field_identifier) @fn)
  arguments: (argument_list))

; Rust
(call_expression
  function: (identifier) @fn_name
  arguments: (arguments))
```

Note Python uses `call` while others use `call_expression`; Go uses `argument_list` while JavaScript and Rust use `arguments`; Go method calls involve `selector_expression` with different field names. These differences must be encoded in language-specific code generators.

**A concrete SQL injection pattern compilation** demonstrates the full pipeline. Starting from the abstract pattern:

```yaml
pattern:
  kind: sql-execution
  with-string-format:
    sink-argument: $QUERY
```

The compiler generates these language-specific tree-sitter queries:

**Python** (detecting `cursor.execute(f"SELECT...")`):
```scheme
(call
  function: (attribute
    object: (identifier) @cursor
    attribute: (identifier) @method)
  (#eq? @method "execute")
  arguments: (argument_list
    (string
      (interpolation) @injection_point)))
```

**JavaScript** (detecting `connection.query(`SELECT...${userId}`)`):
```scheme
(call_expression
  function: (member_expression
    property: (property_identifier) @method)
  (#any-of? @method "query" "execute")
  arguments: (arguments
    (template_string
      (template_substitution) @injection_point)))
```

**Go** (detecting `db.Query(fmt.Sprintf(...))`):
```scheme
(call_expression
  function: (selector_expression
    field: (field_identifier) @method)
  (#any-of? @method "Query" "Exec" "QueryRow")
  arguments: (argument_list
    (call_expression
      function: (selector_expression
        operand: (identifier) @pkg
        field: (field_identifier) @sprintf)
      (#eq? @pkg "fmt")
      (#eq? @sprintf "Sprintf")) @injection_point))
```

**Rust** (detecting `sqlx::query(&format!(...)))`):
```scheme
(call_expression
  function: (scoped_identifier
    path: (identifier) @module
    name: (identifier) @fn)
  (#eq? @module "sqlx")
  (#eq? @fn "query")
  arguments: (arguments
    (reference_expression
      (macro_invocation
        macro: (identifier) @macro_name
        (#eq? @macro_name "format"))) @injection_point))
```

## Lessons from UAST and unified representation attempts

**Babelfish** (now deprecated) attempted pure syntactic unification with "roles" annotating nodes as `Function`, `If`, `Import`, etc. The project revealed fundamental limitations: role annotation is inherently imprecise, language-specific drivers require continuous maintenance, and complete normalization is impossible. The abstraction leaked because language-specific constructs couldn't always map cleanly to universal concepts.

The practical lesson is to **avoid over-unification**. A more successful approach preserves language-specific information while adding semantic annotations for cross-language queries. Joern's CPG exemplifies this—all languages produce the same graph schema, but language-specific constructs are accessible through `PARSER_TYPE_NAME` fields and `UNKNOWN` node types.

**LLVM IR analysis** provides a complementary approach for specific vulnerability classes. IR-level analysis excels at memory safety issues (buffer overflows, use-after-free, integer overflows) where operations become explicit. However, IR analysis fundamentally cannot detect injection vulnerabilities—SQL injection, XSS, command injection—because the semantic context (that a string is a query, that content goes to a web response) is lost during compilation.

The recommended architecture uses **source-level tree-sitter analysis for semantic vulnerabilities** (injection, auth bypass, crypto misuse) and **IR-level analysis for memory vulnerabilities**. A hybrid tool could link findings through source locations.

## The recommended DSL compilation architecture

Based on this research, the optimal architecture for a cross-language security pattern DSL targeting tree-sitter involves four layers:

```
┌─────────────────────────────────────────────────────────────┐
│  Security Pattern DSL (YAML/Custom Syntax)                  │
│  - Abstract patterns with semantic kinds                    │
│  - Metavariables: $VAR, $...ARGS                           │
│  - Taint specifications: sources, sinks, sanitizers         │
└─────────────────────────┬───────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  Abstract Pattern IR (APIR)                                 │
│  - Language-agnostic node types (Call, Assignment, String)  │
│  - Semantic kind annotations                                │
│  - Binding semantics for metavariables                     │
│  - Dataflow requirements (taint paths)                     │
└─────────────────────────┬───────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  Language Mapping Layer                                     │
│  - Python/JS/Go/Rust grammar knowledge                     │
│  - Kind-to-node-type mappings                              │
│  - Library-specific patterns (sqlx, psycopg2, etc.)        │
└──────┬──────────┬──────────┬──────────┬────────────────────┘
       ↓          ↓          ↓          ↓
┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
│ Python   │ │ JS Gen   │ │ Go Gen   │ │ Rust Gen │
│ Generator│ │          │ │          │ │          │
└──────────┘ └──────────┘ └──────────┘ └──────────┘
       ↓          ↓          ↓          ↓
┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐
│Tree-sitter│ │Tree-sitter│ │Tree-sitter│ │Tree-sitter│
│  Query   │ │  Query   │ │  Query   │ │  Query   │
│ (Python) │ │   (JS)   │ │   (Go)   │ │  (Rust)  │
└──────────┘ └──────────┘ └──────────┘ └──────────┘
```

**Key design decisions:**

1. **The APIR should model intent, not syntax.** Instead of representing "function call with identifier," model "invocation of capability" with annotations for which capability (database execution, file operation, network request).

2. **Mapping tables should be extensible.** New libraries (a new ORM, a new web framework) should be addable through configuration rather than code changes. Semgrep's "models-as-data" and CodeQL's YAML-based library models provide good templates.

3. **Pattern combinators should compose.** Support `all`, `any`, `not`, `inside`, `follows` at the APIR level so complex patterns can be built from simpler ones.

4. **Taint analysis requires special handling.** Tree-sitter queries alone cannot express taint flow—they only match static patterns. For true taint detection, generate queries that identify sources and sinks, then perform dataflow analysis in a separate pass (as Semgrep's taint mode does).

5. **Generate multiple query variants per pattern.** A single abstract pattern for "SQL execution with string formatting" might generate 5-10 tree-sitter queries per language to cover different library APIs and formatting styles.

## Remediation guidance should be CWE-anchored

Cross-language remediation benefits from anchoring fixes to CWE identifiers, which provide language-agnostic weakness descriptions with language-specific mitigation guidance. For each vulnerability pattern, the DSL should support fix templates:

```yaml
rule:
  id: sql-injection-string-concat
  # ... detection pattern ...
  fixes:
    python:
      pattern: cursor.execute($QUERY)
      replacement: cursor.execute($QUERY_TEMPLATE, ($PARAMS,))
      requires-refactoring: true  # Can't auto-fix complex cases
    javascript:
      pattern: connection.query(`${$QUERY}`)
      replacement: connection.query($QUERY_TEMPLATE, [$PARAMS])
    go:
      pattern: db.Query(fmt.Sprintf($FMT, $ARGS))
      replacement: db.Query($QUERY_TEMPLATE, $ARGS)
    rust:
      pattern: sqlx::query(&format!($FMT, $ARGS))
      replacement: sqlx::query!($QUERY_TEMPLATE, $ARGS)
```

**Ast-grep** provides a practical model for pattern-based fixes with its YAML rule system and `fix` directive. For semantic fixes requiring context (extracting format arguments, determining parameter order), LLM-assisted remediation is emerging as a practical approach, with Semgrep Assistant demonstrating GPT-4-powered fix suggestions using OWASP documentation embeddings.

## What a minimal viable implementation looks like

For a practical starting point, implement these components:

1. **Pattern parser** handling YAML input with abstract patterns, metavariables, and semantic kinds
2. **Mapping registry** with JSON/YAML configuration files defining kind-to-tree-sitter-pattern mappings per language
3. **Query generators** for each target language that expand abstract patterns using the mappings
4. **Query validator** that parses generated tree-sitter queries to ensure syntactic validity
5. **Test framework** with labeled code samples (vulnerable/safe) per language to validate pattern accuracy

The initial mapping registry for SQL injection detection in Python might look like:

```yaml
python:
  semantic-kinds:
    sql-execution:
      patterns:
        - node: call
          function-match:
            attribute:
              methods: [execute, executemany, executescript]
              objects: [cursor, connection, engine, session]
        - node: call
          function-match:
            scoped: [sqlalchemy.text, sqlite3.execute]
    string-format:
      patterns:
        - node: string
          contains: interpolation  # f-strings
        - node: call
          function-match:
            methods: [format]
            on-type: string
        - node: binary_expression
          operator: "%"
          right-type: [tuple, identifier]
```

This configuration drives the query generator to produce appropriate tree-sitter patterns for each combination of SQL execution method and string formatting approach.

## The fundamental trade-offs to accept

Building this system requires accepting certain trade-offs:

**Precision vs. generality:** Abstract patterns that work across languages will necessarily be less precise than language-specific rules. Accept that some patterns require language-specific variants rather than forcing artificial unification.

**Completeness vs. maintainability:** Covering every library and API pattern for each vulnerability type across four languages is a long-tail problem. Prioritize the most common libraries (sqlx, psycopg2, pg for databases) and provide extensibility for users to add their own mappings.

**Syntactic vs. semantic detection:** Tree-sitter queries match syntax, not semantics. True taint analysis, inter-procedural flow, and type-aware matching require additional infrastructure beyond query generation. The DSL can generate the query patterns, but full vulnerability detection needs a runtime that executes queries and performs additional analysis.

**Tool ecosystem integration:** Rather than building everything from scratch, consider integration with existing tools. Semgrep for taint analysis, ast-grep for search/replace, or even generating CodeQL queries for deep semantic analysis could complement tree-sitter-based syntactic matching.

The research indicates this is an achievable but complex engineering challenge. The key insight is that cross-language abstraction works well for common patterns but breaks down for language-specific idioms—a successful tool embraces this reality with a flexible architecture that handles both universal and language-specific patterns gracefully.