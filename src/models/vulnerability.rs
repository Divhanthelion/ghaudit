//! Vulnerability data models.

use serde::{Deserialize, Serialize};

/// Represents a known vulnerability from a database (OSV, CVE, etc.).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    /// Unique vulnerability ID (e.g., CVE-2024-1234, RUSTSEC-2024-0001)
    pub id: String,

    /// Alternative IDs (aliases)
    #[serde(default)]
    pub aliases: Vec<String>,

    /// Human-readable summary
    pub summary: String,

    /// Detailed description
    pub details: Option<String>,

    /// Severity rating
    pub severity: Severity,

    /// CVSS score (if available)
    pub cvss_score: Option<f64>,

    /// Affected package name
    pub package: String,

    /// Affected version ranges
    pub affected_versions: Vec<VersionRange>,

    /// Fixed version (if known)
    pub fixed_version: Option<String>,

    /// References (links to advisories, patches, etc.)
    #[serde(default)]
    pub references: Vec<Reference>,

    /// CWE IDs
    #[serde(default)]
    pub cwes: Vec<String>,

    /// Publication date
    pub published: Option<chrono::DateTime<chrono::Utc>>,

    /// Last modified date
    pub modified: Option<chrono::DateTime<chrono::Utc>>,

    /// Source database
    pub source: VulnerabilitySource,
}

/// Severity levels for vulnerabilities.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Severity {
    Unknown,
    None,
    Low,
    Medium,
    High,
    Critical,
}

impl Default for Severity {
    fn default() -> Self {
        Severity::Unknown
    }
}

impl Severity {
    /// Create severity from CVSS v3 score.
    pub fn from_cvss(score: f64) -> Self {
        match score {
            s if s >= 9.0 => Severity::Critical,
            s if s >= 7.0 => Severity::High,
            s if s >= 4.0 => Severity::Medium,
            s if s > 0.0 => Severity::Low,
            s if s == 0.0 => Severity::None,
            _ => Severity::Unknown,
        }
    }

    /// Get display color for terminal output.
    pub fn color(&self) -> &'static str {
        match self {
            Severity::Critical => "\x1b[91m", // Bright red
            Severity::High => "\x1b[31m",     // Red
            Severity::Medium => "\x1b[33m",   // Yellow
            Severity::Low => "\x1b[36m",      // Cyan
            Severity::None => "\x1b[32m",     // Green
            Severity::Unknown => "\x1b[37m",  // White
        }
    }
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Severity::Unknown => write!(f, "UNKNOWN"),
            Severity::None => write!(f, "NONE"),
            Severity::Low => write!(f, "LOW"),
            Severity::Medium => write!(f, "MEDIUM"),
            Severity::High => write!(f, "HIGH"),
            Severity::Critical => write!(f, "CRITICAL"),
        }
    }
}

/// Version range specification.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionRange {
    /// Starting version (inclusive)
    pub introduced: Option<String>,

    /// Ending version (exclusive) - the fix version
    pub fixed: Option<String>,

    /// Last affected version
    pub last_affected: Option<String>,
}

impl VersionRange {
    /// Check if a version is within this range.
    pub fn contains(&self, version: &semver::Version) -> bool {
        let in_range = if let Some(ref introduced) = self.introduced {
            if let Ok(intro) = semver::Version::parse(introduced) {
                version >= &intro
            } else {
                true // Assume in range if we can't parse
            }
        } else {
            true // No lower bound
        };

        if !in_range {
            return false;
        }

        if let Some(ref fixed) = self.fixed {
            if let Ok(fix) = semver::Version::parse(fixed) {
                return version < &fix;
            }
        }

        if let Some(ref last) = self.last_affected {
            if let Ok(last_ver) = semver::Version::parse(last) {
                return version <= &last_ver;
            }
        }

        true
    }
}

/// Reference link for vulnerability.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Reference {
    /// Reference type
    pub ref_type: ReferenceType,

    /// URL
    pub url: String,
}

/// Types of vulnerability references.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ReferenceType {
    Advisory,
    Article,
    Detection,
    Discussion,
    Report,
    Fix,
    Introduced,
    Package,
    Evidence,
    Web,
}

impl Default for ReferenceType {
    fn default() -> Self {
        ReferenceType::Web
    }
}

/// Source database for vulnerability data.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum VulnerabilitySource {
    Osv,
    RustSec,
    Nvd,
    GitHub,
    Snyk,
    DepsDevAdvisory,
    Other(String),
}

impl Default for VulnerabilitySource {
    fn default() -> Self {
        VulnerabilitySource::Other("unknown".to_string())
    }
}

/// Dependency information from Cargo.lock or similar.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dependency {
    /// Package name
    pub name: String,

    /// Resolved version
    pub version: String,

    /// Package source (registry, git, path)
    pub source: Option<String>,

    /// Checksum/hash
    pub checksum: Option<String>,

    /// Direct or transitive dependency
    pub is_direct: bool,

    /// Dependencies of this package
    #[serde(default)]
    pub dependencies: Vec<String>,
}

impl Dependency {
    /// Parse the version as semver.
    pub fn semver_version(&self) -> Option<semver::Version> {
        semver::Version::parse(&self.version).ok()
    }
}

/// Provenance information for supply chain verification.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Provenance {
    /// SLSA level (0-4)
    pub slsa_level: u8,

    /// Whether the artifact has a valid signature
    pub signature_valid: bool,

    /// Builder identity (e.g., GitHub Actions workflow)
    pub builder: Option<String>,

    /// Source repository
    pub source_repo: Option<String>,

    /// Source commit
    pub source_commit: Option<String>,

    /// Build timestamp
    pub build_time: Option<chrono::DateTime<chrono::Utc>>,

    /// Verification errors
    #[serde(default)]
    pub errors: Vec<String>,
}

impl Default for Provenance {
    fn default() -> Self {
        Self {
            slsa_level: 0,
            signature_valid: false,
            builder: None,
            source_repo: None,
            source_commit: None,
            build_time: None,
            errors: Vec::new(),
        }
    }
}
